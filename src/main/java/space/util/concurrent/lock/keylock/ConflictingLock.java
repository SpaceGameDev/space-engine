package space.util.concurrent.lock.keylock;

import org.jetbrains.annotations.NotNull;
import space.util.concurrent.awaitable.Awaitable;
import space.util.concurrent.awaitable.LockLikeSignalable;
import space.util.indexmap.IndexMap;
import space.util.indexmap.IndexMapArray;
import space.util.indexmap.multi.IndexMultiMap;
import space.util.indexmap.multi.IndexMultiMap2D;
import space.util.key.IllegalKeyException;
import space.util.key.Key;
import space.util.key.KeyGenerator;

import java.util.concurrent.TimeUnit;

/**
 * The conflicting Lock is an advanced Implementation of the KeyLock which allows you to setup complicated conflict dependencies.
 * But it requires you to use {@link Key} as the Key and that the Keys are generated by the internal Generator.
 */
public class ConflictingLock implements KeyLock<Key<?>> {
	
	public static final Object TRUE = new Object();
	
	public IndexMap<LockLikeSignalable> holders;
	public IndexMultiMap<Object> conflictMap;
	public KeyGenerator gen;
	public int size;
	
	public ConflictingLock(KeyGenerator gen, int size) {
		this(new IndexMapArray<>(), new IndexMultiMap2D<>(), gen, size);
	}
	
	public ConflictingLock(IndexMap<LockLikeSignalable> holders, IndexMultiMap<Object> conflictMap, KeyGenerator gen, int size) {
		this.holders = holders;
		this.conflictMap = conflictMap;
		this.gen = gen;
		this.size = size;
	}
	
	//methods
	public void check(Key<?> key) {
		if (gen != null && !gen.isKeyOf(key))
			throw new IllegalKeyException();
		if (key.getID() >= size)
			throw new IllegalStateException();
	}
	
	public void ensureKeyCapacity(int newSize) {
		if (newSize >= size)
			return;
		for (int i = size; i < newSize; i++)
			holders.put(i, new LockLikeSignalable());
		size = newSize;
	}
	
	public void ensureKeyCapacityIndex(int newSize) {
		ensureKeyCapacity(newSize + 1);
	}
	
	public KeyGenerator makeModifiedKeyGenerator() {
		return gen.whenGenerated(key -> ensureKeyCapacityIndex(key.getID()));
	}
	
	//conflict
	
	/**
	 * will add a conflict
	 *
	 * @param acquiring the {@link Key} trying to acquire the lock
	 * @param holding   the {@link Key} currently holding the lock, which will block any acquire attempts when {@link Key} is acquiring
	 */
	public void addConflict(Key<?> acquiring, Key<?> holding) {
		setConflict(acquiring, holding, true);
	}
	
	/**
	 * will remove a conflict
	 *
	 * @param acquiring the {@link Key} trying to acquire the lock
	 * @param holding   the {@link Key} currently holding the lock, which will block any acquire attempts when {@link Key} is acquiring
	 */
	public void removeConflict(Key<?> acquiring, Key<?> holding) {
		setConflict(acquiring, holding, false);
	}
	
	/**
	 * will set a conflict's existence
	 *
	 * @param acquiring the {@link Key} trying to acquire the lock
	 * @param holding   the {@link Key} currently holding the lock, which will block any acquire attempts when {@link Key} is acquiring
	 */
	public void setConflict(Key<?> acquiring, Key<?> holding, boolean value) {
		synchronized (this) {
			check(acquiring);
			check(holding);
			if (value) {
				conflictMap.put(new int[] {acquiring.getID(), holding.getID()}, TRUE);
			} else {
				conflictMap.remove(new int[] {acquiring.getID(), holding.getID()});
			}
		}
	}
	
	//conflict Bidirectional
	
	/**
	 * will add a conflict bidirectional
	 */
	public void addConflictBidirectional(Key<?> key1, Key<?> key2) {
		setConflictBidirectional(key1, key2, true);
	}
	
	/**
	 * will remove a conflict bidirectional
	 */
	public void removeConflictBidirectional(Key<?> key1, Key<?> key2) {
		setConflictBidirectional(key1, key2, false);
	}
	
	/**
	 * will set a conflict's existence bidirectional
	 */
	public void setConflictBidirectional(Key<?> key1, Key<?> key2, boolean value) {
		setConflict(key1, key2, value);
		setConflict(key2, key1, value);
	}
	
	//conflict self
	
	/**
	 * will add a conflict bidirectional
	 */
	public void addSelfConflict(Key<?> key) {
		setConflictBidirectional(key, key, true);
	}
	
	/**
	 * will remove a conflict bidirectional
	 */
	public void removeSelfConflict(Key<?> key) {
		setConflictBidirectional(key, key, false);
	}
	
	/**
	 * will set a conflict's existence bidirectional
	 */
	public void setSelfConflict(Key<?> key, boolean value) {
		setConflict(key, key, value);
	}
	
	//lock
	@Override
	public void lock(@NotNull Key<?> key) {
		check(key);
		while (true) {
			Awaitable await;
			synchronized (this) {
				await = internalCheckLock(key);
				if (await == null) {
					internalForceLock(key);
					return;
				}
			}
			
			try {
				await.await();
			} catch (InterruptedException ignore) {
			
			}
		}
	}
	
	@Override
	public void lock(@NotNull Key<?> key, long time, TimeUnit unit) {
		check(key);
		while (true) {
			Awaitable await;
			synchronized (this) {
				await = internalCheckLock(key);
				if (await == null) {
					internalForceLock(key);
					return;
				}
			}
			
			try {
				await.await(time, unit);
			} catch (InterruptedException ignore) {
			
			}
		}
	}
	
	@Override
	public void lockInterruptibly(@NotNull Key<?> key) throws InterruptedException {
		check(key);
		while (true) {
			Awaitable await;
			synchronized (this) {
				await = internalCheckLock(key);
				if (await == null) {
					internalForceLock(key);
					return;
				}
			}
			await.await();
		}
	}
	
	@Override
	public synchronized void lockInterruptibly(@NotNull Key<?> key, long time, TimeUnit unit) throws InterruptedException {
		check(key);
		while (true) {
			Awaitable await;
			synchronized (this) {
				await = internalCheckLock(key);
				if (await == null) {
					internalForceLock(key);
					return;
				}
			}
			await.await(time, unit);
		}
	}
	
	@Override
	public synchronized boolean tryLock(@NotNull Key<?> key) {
		check(key);
		Awaitable await;
		synchronized (this) {
			await = internalCheckLock(key);
			if (await == null) {
				internalForceLock(key);
				return true;
			}
		}
		return false;
	}
	
	//unlock
	@Override
	public synchronized void unlock(@NotNull Key<?> key) {
		check(key);
		internalForceUnlock(key);
	}
	
	//unsupported
	@Override
	public synchronized boolean tryUnlock(@NotNull Key<?> key) {
		throw new UnsupportedOperationException();
	}
	
	@Override
	@Deprecated
	public synchronized boolean isLocked() {
		throw new UnsupportedOperationException();
	}
	
	@NotNull
	@Override
	@Deprecated
	public Key<?> getHolder() {
		throw new UnsupportedOperationException();
	}
	
	//private
	protected Awaitable internalCheckLock(Key<?> key) {
		int id = key.getID();
		int[] pos = new int[2];
		pos[0] = id;
		
		for (int i = 0; i < size; i++) {
			pos[1] = i;
			Object conf = conflictMap.get(pos);
			if (conf == null)
				continue;
			LockLikeSignalable await = holders.get(i);
			if (await.isSignaled())
				continue;
			return await;
		}
		return null;
	}
	
	protected void internalForceLock(Key<?> key) {
		holders.get(key.getID()).reset();
	}
	
	protected void internalForceUnlock(Key<?> key) {
		holders.get(key.getID()).signal();
	}
}
